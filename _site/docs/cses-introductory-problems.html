<!DOCTYPE html>
<html lang="en" class="html" data-theme="dark"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>
    
      Cses Introductory Problems
    
  </title>

  <!-- Begin Jekyll SEO tag v2.7.3 -->
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Cses Introductory Problems" />
<meta name="author" content="Malladi Pradyumna" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1. Weird Algorithm" />
<meta property="og:description" content="1. Weird Algorithm" />
<link rel="canonical" href="http://localhost:4000/cses-introductory-problems" />
<meta property="og:url" content="http://localhost:4000/cses-introductory-problems" />
<meta property="og:site_name" content="Pradyumna Malladi" />
<meta property="og:image" content="https://soopr.xyz/images/card?url=http://localhost:4000/cses-introductory-problems" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-06-13T00:00:00+05:30" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="og:image" content="https://soopr.xyz/images/card?url=http://localhost:4000/cses-introductory-problems" />
<meta property="twitter:title" content="Cses Introductory Problems" />
<meta name="twitter:site" content="@na" />
<meta name="twitter:creator" content="@Malladi Pradyumna" />
<script type="application/ld+json">
{"description":"1. Weird Algorithm","headline":"Cses Introductory Problems","dateModified":"2023-06-13T00:00:00+05:30","datePublished":"2023-06-13T00:00:00+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/cses-introductory-problems"},"url":"http://localhost:4000/cses-introductory-problems","author":{"@type":"Person","name":"Malladi Pradyumna"},"@type":"BlogPosting","@context":"https://schema.org"}</script>
<script async defer data-soopr-token="" src="https://sdk.soopr.co/soopr.js"  ></script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Pradyumna Malladi" />

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicon/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png">
  <link rel="manifest" href="/assets/images/favicon/site.webmanifest">
  <link rel="mask-icon" href="/assets/images/favicon/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="/assets/images/favicon/favicon.ico">
  <meta name="msapplication-TileColor" content="#00aba9">
  <meta name="msapplication-config" content="/assets/images/favicon/browserconfig.xml">
  <meta name="theme-color" content="#ffffff">
  <!-- Favicon -->

  <link rel="stylesheet" href="/assets/css/main.css" />
  
    <script type="text/javascript">
  window.addEventListener('load', themeChange);
  const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
  if (currentTheme)
    document.documentElement.setAttribute('data-theme', currentTheme);

  function themeChange() {
    let button = document.querySelector('.theme-toggle');

    button.addEventListener('click', function (e) {
      let currentTheme = document.documentElement.getAttribute('data-theme');
      if (currentTheme === 'dark') {
        transition();
        document.documentElement.setAttribute('data-theme', 'light');
        localStorage.setItem('theme', 'light');
      } else {
        transition();
        document.documentElement.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
      }
    });

    let transition = () => {
      document.documentElement.classList.add('transition');
      window.setTimeout(() => {
        document.documentElement.classList.remove('transition');
      }, 1000);
    }
  }
</script>


  

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-K6YQF2GG7C"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-K6YQF2GG7C');
</script></head>
<body>
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">/home</a>
<h1 class="post-title">Cses Introductory Problems</h1>
<p class="post-date text-bold">
  
    <span class="text-upcase">Malladi Pradyumna</span> / 
  
  
    <span class="text-upcase">June 2023</span>
  


  
  
  (2923 Words, 
  17 Minutes)
  

</p>

<div class="soopr-btn"
   data-twitter="SooprCo"
>
</div>


  <div class="">
    
    <span class="tag">welcome</span>
    
    <span class="tag">miscellaneous</span>
    
  </div>


<h1 id="1-weird-algorithm">1. Weird Algorithm</h1>

<p>Let’s try the most obvious solution:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void steps(int n) {
    while (n != 1) {
        std::cout&lt;&lt;n&lt;&lt;" ";
        if (n % 2 == 0) {
            n /= 2;
        } else {
            n = 3 * n + 1;
        }
    }
    std::cout&lt;&lt;n;
    return;
}
</code></pre></div></div>
<h3 id="result">Result:</h3>

<p>TIME LIMIT EXCEEDED on some test cases.</p>

<p>WRONG ANSWER on some test cases.</p>

<p>Wrong answer probably means some overflow occurred. Let’s try changing all the <code class="language-plaintext highlighter-rouge">int</code> to <code class="language-plaintext highlighter-rouge">long</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void steps(long n) {
    while (n != 1) {
        std::cout&lt;&lt;n&lt;&lt;" ";
        if (n % 2 == 0) {
            n /= 2;
        } else {
            n = 3 * n + 1;
        }
    }
    std::cout&lt;&lt;n;
    return;
}
</code></pre></div></div>

<h3 id="result-1">Result:</h3>
<p>ACCEPTED on all test cases!</p>

<h1 id="2-missing-number">2. Missing Number</h1>

<p>This is actually a very simple problem. We can find the sum of first n numbers by <code class="language-plaintext highlighter-rouge">n*(n+1)/2</code> and just subtract the sum of the numbers we received.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;

int main(void){
    long n, sum=0;
    std::cin&gt;&gt;n;
    for(long i=0;i&lt;n-1;i++){
        long no;
        std::cin&gt;&gt;no;
        sum+=no;
    }
    long actual_sum = n*(n+1)/2;
    long missing = actual_sum - sum;
    std::cout&lt;&lt;missing;
    return 0;
}
</code></pre></div></div>

<h3 id="result-2">Result:</h3>

<p>ACCEPTED!</p>

<h1 id="3-repetitions">3. Repetitions</h1>

<p>From what I understood we have to find the length of the longest repeating character sequence without gaps.</p>

<p>Let’s try the O(N) approach.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main(void){
    std::string s;
    std::cin &gt;&gt; s;
    long len = s.length();
    long ans = 1;
    long max = 1;
    for(long i=0;i&lt;len;i++){
        if(i&lt;len-1){
            if(s[i]==s[i+1]){
                max++;
            } else {
                ans = std::max(max, ans);
                max = 1;
            }
        } else {
            ans = std::max(max, ans);
        }
    }
    std::cout&lt;&lt;ans;
    return 0;
}
</code></pre></div></div>
<p>Result: ACCEPTED!</p>

<p>Nice!</p>

<h1 id="4-increasing-array">4. Increasing Array</h1>

<p><code class="language-plaintext highlighter-rouge">You are given an array of n
 integers. You want to modify the array so that it is increasing, i.e., every element is at least as large as the previous element.
</code></p>

<p>So a solution is obvious:</p>
<ol>
  <li>Go through all the elements</li>
  <li>If an element is less than the previous element (if any) we need to increase it.<br /><code class="language-plaintext highlighter-rouge">No of moves required = previous element - current element</code></li>
  <li>Update the current element to the previous value.</li>
  <li>Add up all the moves required.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;

int main(void){
    long n;
    long moves = 0;
    long prev = -1;
    std::cin&gt;&gt;n;
    for (long i = 0; i &lt; n; i++)
    {
        long val;
        std::cin &gt;&gt; val;
        if (i &gt; 0) {
            if (val &lt; prev) {
                moves += prev - val;
                val = prev;
            }
        }
        prev = val;
    }
    std::cout&lt;&lt;moves;
    return 0;
}
</code></pre></div></div>
<h3 id="result-3">Result:</h3>

<p>ACCEPTED</p>

<h1 id="5-permutations">5. Permutations</h1>

<p>I need to thank Rupanuga Mishra for the logic for this one. I simply couldn’t figure it out :”(</p>

<p>Logic is simple:</p>
<ol>
  <li>Loop from <code class="language-plaintext highlighter-rouge">i=0 to i=n/2 (i++)</code></li>
  <li>Print the <code class="language-plaintext highlighter-rouge">ith</code> and <code class="language-plaintext highlighter-rouge">n/2+ith</code> numbers one after another</li>
</ol>

<p>Quick Implementation:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(long i=1;i&lt;=n/2;i++){
    std::cout&lt;&lt;i&lt;&lt;" "&lt;&lt;i+n/2&lt;&lt;" ";
}
// If odd print the last one also
if(n%2==1){std::cout&lt;&lt;n&lt;&lt;" ";}
</code></pre></div></div>
<h3 id="result-4">Result:</h3>
<p>FAILED on many test cases.</p>

<p>Seeing the test cases it failed, I noticed a similarity. They are all either:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">n==odd</code> or <code class="language-plaintext highlighter-rouge">n&lt;6</code></li>
</ol>

<p>For <code class="language-plaintext highlighter-rouge">n==odd</code> the last two numbers were <code class="language-plaintext highlighter-rouge">n-1</code> and <code class="language-plaintext highlighter-rouge">n</code> so moving the if statement at the end 
to the beginning should fix it. (Thanks Dhruv!)</p>

<p>For the <code class="language-plaintext highlighter-rouge">n&lt;6</code> I just added edge conditions (cheating according to Dhruv but it works haha)!</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;iostream&gt;

int main(void){
    long n;
    std::cin&gt;&gt;n;
    if(n==4){
        std::cout&lt;&lt;"3 1 4 2";
        return 0;
    }
    if(n==5){
        std::cout&lt;&lt;"2 4 1 3 5";
        return 0;
    }
    if(n==1){
        std::cout&lt;&lt;"1";
        return 0;
    }
    if(n&lt;6){std::cout&lt;&lt;"NO SOLUTION"; return 0;}
    // If odd print the last one also
    if(n%2==1){std::cout&lt;&lt;n&lt;&lt;" ";}
    for(long i=1;i&lt;=n/2;i++){
        std::cout&lt;&lt;i&lt;&lt;" "&lt;&lt;i+n/2&lt;&lt;" ";
    }
    return 0;
}
</code></pre></div></div>
<h3 id="result-5">Result:</h3>
<p>ACCEPTED!</p>

<h1 id="6-number-spiral">6. Number Spiral</h1>

<p>Sadly I could not think of any elegant solution to the problem. After looking at it it seemed that the
solution could be found using some elaborate <code class="language-plaintext highlighter-rouge">if-else</code> blocks and so I did that.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Usage: find_no(y-1, x-1)
long find_no(long row, long col){
    long num;
    // Lower Left
    if (row&gt;col){
        long starting_element_of_row = row%2==1? (row+1)*(row+1) : row*row+1; 
        num = row%2==0? starting_element_of_row + col : starting_element_of_row - col;
    } 
    // Upper Right
    else if (row&lt;col) {
        long starting_element_of_column = col%2==0? (col+1)*(col+1) : col*col+1; 
        num = col%2==0? starting_element_of_column - row : starting_element_of_column + row; 
    } else 
    // Diagonal
    {
        num = row*row+row+1;
    }
    return num;
}
</code></pre></div></div>

<h3 id="result-6">Result:</h3>
<p>ACCEPTED!</p>

<h1 id="7-two-knights">7. Two Knights</h1>

<p>This is a O(1) solution because there is a direct formula for the no of positions given a chessboard of some dimension.</p>

<p>Let’s say there is a KxK chessboard. We can place two knights in it in <code class="language-plaintext highlighter-rouge">K^2C2</code> possible ways. How many of these ways make the two knights attack each other?</p>

<p>If two knights are attacking each other, they are at the corner squares of a <code class="language-plaintext highlighter-rouge">3x2</code> rectangle. In a <code class="language-plaintext highlighter-rouge">3x2</code> rectangle there are 4 ways we can arrange two knights so as to attack each other. So now how many 3x2 rectangles can we construct in a KxK chessboard?</p>

<p>Translating along the y-axis, we can have <code class="language-plaintext highlighter-rouge">K-3+1 = K-2</code> positions for the rectangle.
Translating along the x-axis, we can have <code class="language-plaintext highlighter-rouge">K-2+1 = K-1</code> positions for the rectangle.</p>

<p>Total no of positions where the two knights are attacking each other: <code class="language-plaintext highlighter-rouge">4*(K-2)*(K-1)</code></p>

<p>Total no of positions where the two knights are NOT attacking each other: <code class="language-plaintext highlighter-rouge">K^2C2-4*(K-2)*(K-1)</code></p>

<p>Quick Implementation:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>long no_of_ways(long n){
    return (n*n*(n*n-1))/2 - 4*(n-1)*(n-2); 
}

int main(void){
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    long n;
    std::cin&gt;&gt;n;
    for(long i=1;i&lt;=n;i++){
        std::cout&lt;&lt;no_of_ways(i)&lt;&lt;std::endl;
    }
    return 0;
}
</code></pre></div></div>

<h3 id="result-7">Result:</h3>
<p>ACCEPTED!</p>

<p>Luckily there were no edge cases for this problem!</p>

<h1 id="8-two-sets">8. Two Sets</h1>

<p>So, I looked online and found out it is a DP Problem (which I unfortunately never learnt properly during my DSA Course.) Going briefly through some online brief explanations I saw the overall logic.</p>

<p>Let us say we have a set like this: <code class="language-plaintext highlighter-rouge">{1,2,3,4,5,6,7}</code>
The sum of the elements is <code class="language-plaintext highlighter-rouge">28</code> so we need to make two sets summing up to <code class="language-plaintext highlighter-rouge">14</code> each.</p>

<h1 id="todo">todo!()</h1>

<h1 id="9-bit-strings">9. Bit Strings</h1>

<p>This is a very simple problem. We just need to find 2^input. This can be done directly using a bitwise operation</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;iostream&gt;

int main(void){
    const long MOD = 1000000007; // 10^9 + 7
    long input;
    std::cin&gt;&gt;input;
    long result = 1 &lt;&lt; input;
    std::cout&lt;&lt;result%MOD;
    return 0;
}
</code></pre></div></div>
<h3 id="result-8">Result:</h3>
<p>FAILED on some test cases.</p>

<p>Observing a failed test case <code class="language-plaintext highlighter-rouge">input=447</code> we are getting negative values for both <code class="language-plaintext highlighter-rouge">2^result</code> and the final answer. We need to find a better way to do the power and % operations.</p>

<p>Luckily on googling I found this: https://www.geeksforgeeks.org/exponential-squaring-fast-modulo-multiplication/</p>

<p>Now let us use this method in our code. Basically we find <code class="language-plaintext highlighter-rouge">2^input % MOD</code> in a series of steps i=1 to i=n each time multiplying our input by 2 and taking the MOD.</p>

<p>The property used is: <code class="language-plaintext highlighter-rouge">a*a % mod = (a%mod) * (a%mod)</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;iostream&gt;

int main(void){
    const long long MOD = 1000000007; // 10^9 + 7
    long long input;
    std::cin&gt;&gt;input;
    long long res = 1;
    for(long long i=0;i&lt;input;i++){
        res = (res*2);
        res = res%MOD;
    }
    std::cout&lt;&lt;res;
    return 0;
}
</code></pre></div></div>
<h3 id="result-9">Result:</h3>
<p>ACCEPTED!
Cool let’s move on to the next one!</p>

<h1 id="10-trailing-zeros">10. Trailing Zeros</h1>

<p>Luckily this is a JEE Problem. We need to find the no of multiples of <code class="language-plaintext highlighter-rouge">5</code> in all the numbers upto the input number as that will give us the no of zeros.</p>

<p><code class="language-plaintext highlighter-rouge">5</code> can come as either <code class="language-plaintext highlighter-rouge">5</code> or any of it’s powers. No of occurences of <code class="language-plaintext highlighter-rouge">5^k</code> in the numbers upto <code class="language-plaintext highlighter-rouge">input</code> is <code class="language-plaintext highlighter-rouge">box[input/5^k]</code></p>

<p>Quick Soln using this:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;iostream&gt;

int main(void){
    long long n;
    std::cin&gt;&gt;n;
    long long zeros = 0;
    for(long long i=5;i&lt;=n;i*=5){
        zeros += n/i;
        if(zeros==0) {
            break;
        }
    }
    std::cout&lt;&lt;zeros;
    return 0;
}
</code></pre></div></div>
<h3 id="result-10">Result:</h3>
<p>ACCEPTED!</p>

<h1 id="11-coin-piles">11. Coin Piles</h1>

<p>So some maths now:
Let <code class="language-plaintext highlighter-rouge">a = coins in left pile</code>
Let <code class="language-plaintext highlighter-rouge">b = coins in right pile</code></p>

<p>We have two options for each of our operations:</p>
<ol>
  <li>Remove 2 coins from a and 1 coin from b</li>
  <li>Remove 1 coin from a and 2 coins from b</li>
</ol>

<p>Let <code class="language-plaintext highlighter-rouge">x = no of times 1 was performed</code>.
Let <code class="language-plaintext highlighter-rouge">y = no of times 2 was performed</code>.</p>

<p>So, <code class="language-plaintext highlighter-rouge">total no of moves = x+y</code>.</p>

<p>If at the end of <code class="language-plaintext highlighter-rouge">x+y</code> operations, the two piles became empty, we have two conditions:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">a = x*2 + y</code></li>
  <li><code class="language-plaintext highlighter-rouge">b = x + 2*y</code></li>
</ol>

<p>Adding:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">a + b = 3*(x + y)</code></li>
</ol>

<p>So, we have 1 condition: That the sum of the two piles must be a multiple of 3!</p>

<p>But, this condition is not sufficient. We have one more also!</p>

<p>Let one pile be incredibly large and the other be incredibly small (less than twice the size of the other)! We keep on removing 2 elements from the bigger and one from the smaller but the smaller pile becomes empty first!!</p>

<p>So, we need to ensure that the bigger pile is no bigger than twice the smaller!</p>

<p>Quick Implementation:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;

int main(void){
    long long t;
    std::cin &gt;&gt; t;
    for (long long i = 0; i&lt;t; i++){
        long long a, b;
        std::cin &gt;&gt; a &gt;&gt; b;
        if ((a+b)%3 == 0 &amp;&amp; 2*a &gt;= b &amp;&amp; 2*b &gt;= a)
            std::cout &lt;&lt; "YES" &lt;&lt; std::endl;
        else
            std::cout &lt;&lt; "NO" &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre></div></div>
<h3 id="result-11">RESULT:</h3>
<p>ACCEPTED!</p>

<h1 id="12-palindrome-string">12. Palindrome String</h1>

<p>First, we make a frequency array for the string. We see that if the total number of characters having odd frequency is odd, no such palindrome is possible.</p>

<p>Let’s say we have the frequency array and making a palindrome is possible. How to make it?</p>

<p>Let us make 2 strings for the left and right halves of the palindrome. Now let’s go through our freq array from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">26</code>. If a character has even frequency, we can keep half of the count in the starting of palindrome and half at the end. If it has odd frequency just keep all of them in the middle!</p>

<p>Not so quick implementation xD</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;iostream&gt;

int main(void){
    std::string input;
    std::cin&gt;&gt;input;
    int freq[26] = {0};
    for(int i=0; i&lt;input.length(); i++){
        freq[input[i]-'A']++;
    }
    bool isOdd = input.length()%2 == 1;
    int noOfOdd = 0;
    for(int i=0; i&lt;26; i++){
        if(freq[i]%2 == 1){
            noOfOdd++;
        }
    }
    if (noOfOdd &gt; 1){
        std::cout&lt;&lt;"NO SOLUTION";
    } else {
        std::string outputleft = "";
        std::string outputright = "";
        // Fill all the even freq characters first
        for(int i=0; i&lt;26; i++){
            if(freq[i]%2 == 0){
                int num = freq[i]/2;
                while(num--){
                    outputleft += (char)('A'+i);
                    outputright += (char)('A'+i);
                }
            }
        }
        // Print the outputleft + odd freq character + outputright
        for(int i=0;i&lt;outputleft.length();i++) std::cout&lt;&lt;outputleft[i];
        for(int i=0;i&lt;26;i++){
            if(freq[i]%2 == 1){
                int num = freq[i];
                while(num--) std::cout&lt;&lt;(char)('A'+i);
            }
        }
        for(int i=outputright.length()-1;i&gt;=0;i--) std::cout&lt;&lt;outputright[i];
    }
    return 0;
}
</code></pre></div></div>

<h3 id="result-12">Result:</h3>
<p>ACCEPTED on all test cases!</p>

<h1 id="13-gray-code">13. Gray Code</h1>

<p>This can be solved by recursion. Assume we already have the Gray Code for some <code class="language-plaintext highlighter-rouge">n</code>. How to get for <code class="language-plaintext highlighter-rouge">n+1</code> ?</p>

<p>Let’s consider the case of <code class="language-plaintext highlighter-rouge">n=2</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GRAY CODE (n = 2):
00
01
11
10
</code></pre></div></div>
<p>Now, for n=3 we observe that if we keep a zero in the starting of these numbers, each still differs by one from the next! Same if we keep a one! Also note that taking both of these together (second one in reverse), we get all the numbers in the gray code for <code class="language-plaintext highlighter-rouge">n=3</code>!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GRAY CODE (n = 3):
000
001
011
010
110
111
101
100
</code></pre></div></div>

<p>Implementation:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::vector&lt;std::string&gt; gray_code(long long n){
    if(n==1){
        std::vector&lt;std::string&gt; vec;
        vec.push_back("0");
        vec.push_back("1");
        return vec;
    } else {
        std::vector&lt;std::string&gt; vec;
        std::vector&lt;std::string&gt; vecprev = gray_code(n-1);
        for(int i=0;i&lt;vecprev.size();i++){
            vec.push_back("0"+vecprev[i]);
        }
        for(int i=vecprev.size()-1;i&gt;=0;i--){
            vec.push_back("1"+vecprev[i]);
        }
        return vec;
    }

}
</code></pre></div></div>

<h3 id="result-13">Result:</h3>
<p>ACCEPTED on all test cases!</p>

<h1 id="14-tower-of-hanoi">14. Tower of Hanoi</h1>

<p>I am really sorry I wrote a really big post for this one but my laptop lost power and everything was gone. Seems the work wasn’t saved (Loving first day of emacs already).</p>

<p>So, A quick summary will have to suffice (No energy for anything more :”(  ) :</p>

<p>The soln is simple. To move N Disks from Tower 1 to Tower 3 using Tower 2, We first move the top N-1 Disks to tower 2 and the Nth (Bottom Most) Disk to Tower 3. Then We Move the N-2 Disks on Tower 2 to Tower 3. It is a simple Recursion problem.</p>

<p>Quick Implementation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;utility&gt;

typedef long long ll;
typedef std::pair&lt;int, int&gt; Move;

void tower_of_hanoi(ll from_tower, ll using_tower, ll to_tower, ll no_of_disks, std::vector&lt;Move&gt; &amp;moves){
    if(no_of_disks == 0){
        // Base Case
        return;
    } else {
        // First move the N-1 disks to the middle tower
        tower_of_hanoi(from_tower, to_tower, using_tower, no_of_disks-1, moves);
        // Move one disk from the left tower to the right tower
        // Add the move to the moves vector
        moves.push_back(std::make_pair(from_tower, to_tower));
        // Move N-1 disks from the middle tower to the right tower
        tower_of_hanoi(using_tower, from_tower, to_tower, no_of_disks-1, moves);
    }
}


int main(void){
    ll n;
    std::cin&gt;&gt;n;
    std::vector&lt;Move&gt; moves;
    tower_of_hanoi(1, 2, 3, n, moves);
    std::cout&lt;&lt;moves.size()&lt;&lt;"\n";
    for(const auto &amp;move: moves) {
        std::cout&lt;&lt;move.first&lt;&lt;" "&lt;&lt;move.second&lt;&lt;"\n";
    }
    return 0;
}

</code></pre></div></div>

<h3 id="result-14">Result:</h3>
<p>ACCEPTED! (on all test cases)</p>

<h1 id="15-creating-strings">15. Creating Strings</h1>

<p>We have to take a string, find all the permutations of it and return the output in alphabetical order.</p>

<p>The method for generating permutations is pretty standard. If we store them in a <code class="language-plaintext highlighter-rouge">std::set</code>, that will take care of the lexicographic ordering automatically for us.</p>

<p>Implementation:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void permute(std::string str, int left, int right, std::set&lt;std::string&gt; &amp;outputs){
  if(left == right) {
    std::cout&lt;&lt;str&lt;&lt;std::endl;
    outputs.insert(str);
  } else {
    for(int i=left;i&lt;=right;i++){
      std::swap(str[left], str[i]);
      permute(str, left+1, right, outputs);
      std::swap(str[left], str[i]);
    }
  }
}

</code></pre></div></div>

<h3 id="result-15">Result:</h3>
<p>ACCEPTED!</p>

<h1 id="16-apple-division">16. Apple Division</h1>

<p>We have a set of some numbers. We have to divide it into two sets such that the difference in the sum of the two sets is the least and we have to find that sum.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ex Input:
5
3 2 7 4 1
Two Sets:
{2,3,4}, {7,1}
</code></pre></div></div>

<p>First let us sort the input:</p>

<p><code class="language-plaintext highlighter-rouge">7,4,3,2,1</code></p>

<p>Then let us take a number from the left and insert into set 1 and take the next numbers till the sum exceeds the first number and insert into set two. If it exceeds, we repeat the process. In this way we can solve the problem!</p>

<p>Eg Soln:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">{7} {4,3,2}</code></li>
  <li><code class="language-plaintext highlighter-rouge">{7,1} {4,3,2}</code></li>
</ol>

<p>Implementation:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;algorithm&gt;
#define ll long long
#define fio std::ios_base::sync_with_stdio(false); std::cin.tie(NULL); std::cout.tie(NULL)

ll abs(ll a){
  if(a&gt;0){
    return a;
  } else {
    return -1*a;
  }
}

ll partition(std::vector&lt;ll&gt; &amp;inputs, std::vector&lt;ll&gt; &amp;grp1, std::vector&lt;ll&gt; &amp;grp2, ll n){
  std::sort(inputs.begin(), inputs.end(), std::greater&lt;ll&gt;());
  bool insert_in_grp1 = true;
  ll sum1 = 0, sum2 = 0;
  for(auto x: inputs){
    if(sum1&gt;=sum2 &amp;&amp; sum1+sum2 != 0){
      insert_in_grp1 = false;
    } else {
      insert_in_grp1 = true;
    };
    if(insert_in_grp1){
      grp1.push_back(x);
      sum1 += x;
    } else {
      grp2.push_back(x);
      sum2 += x;
    }
  }
  return abs(sum1-sum2);
}

int main(void){
  fio;
  ll n;
  ll diff = 0;
  std::cin&gt;&gt;n;
  std::vector&lt;ll&gt; inputs(n);
  std::vector&lt;ll&gt; grp1, grp2;
  for(ll i = 0; i &lt; n; i ++){
    std::cin&gt;&gt;inputs[i];
  }
  diff = partition(inputs, grp1, grp2, n);
  std::cout&lt;&lt;diff;
  return 0;
}
</code></pre></div></div>

<h3 id="result-16">Result:</h3>
<p>FAILED! (On many test cases!)</p>

<p>Maybe we are better off finding all the different possible splits and choosing the minimum difference instead….</p>

<p>Also the constraint is: <code class="language-plaintext highlighter-rouge">1 &lt;= n &lt;= 20</code> which seems very favourible for a slow algorithm.</p>

<p>There is a very simple way to get all divisions of a set into two subsets. We go through all the numbers from <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">2^n -1</code> and the <code class="language-plaintext highlighter-rouge">1/0</code> in the binary representation of each of indicate whether the element at that particular index is present in grp1 or grp2. Let us try to generate all the divisions using this and then go through them and choose the one where the sum is the least!</p>

<p>(Not so quick) implementations!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;limits&gt;

#define ll long long
#define fio std::ios_base::sync_with_stdio(false); std::cin.tie(NULL); std::cout.tie(NULL)

ll partition(const std::vector&lt;ll&gt;&amp; input, std::vector&lt;ll&gt;&amp; grp1, std::vector&lt;ll&gt;&amp; grp2, ll n) {
    std::vector&lt;ll&gt; tmp_grp1, tmp_grp2;
    ll diff = std::numeric_limits&lt;ll&gt;::max();
    for (ll i = 0; i &lt; (1 &lt;&lt; n) - 1; i++) {
        ll sum1 = 0, sum2 = 0;
        tmp_grp1.clear();
        tmp_grp2.clear();
        for (ll index = 0; index &lt; input.size(); index++) {
            if ((i &amp; (1 &lt;&lt; index)) == 0) {
                tmp_grp1.push_back(input[index]);
                sum1 += input[index];
            } else {
                tmp_grp2.push_back(input[index]);
                sum2 += input[index];
            }
        }
        if (std::abs(sum1 - sum2) &lt; diff) {
            diff = std::abs(sum1 - sum2);
            grp1 = tmp_grp1;
            grp2 = tmp_grp2;
        }
    }
    return diff;
}

int main() {
    fio;
    ll n;
    std::cin&gt;&gt;n;
    std::vector&lt;ll&gt; input(n);
    for(ll i = 0; i &lt; n; ++i){
      std::cin&gt;&gt;input[i];
    }
    std::vector&lt;ll&gt; grp1, grp2;
    ll diff = partition(input, grp1, grp2, n);
    std::cout &lt;&lt; diff &lt;&lt; std::endl;

    return 0;
}
</code></pre></div></div>

<h3 id="result-17">Result:</h3>
<p>ACCEPTED! (On all test cases!)</p>

<h1 id="17-chessboard-and-queens">17. Chessboard and Queens</h1>

<p>From now onwards I will not add any explanations as I don’t have much time.</p>

<p>Maybe later I will add the explanations….</p>

<p>Solution:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;iostream&gt;
#define fio std::ios_base::sync_with_stdio(false); std::cin.tie(NULL); std::cout.tie(NULL)

int count = 0;
char board[8][8];
// Availibility of a particular left/right diagonal and row
bool left_diag[15] = {false}, right_diag[15] = {false}, rows[7] = {false};


void calculate_possibilities(int col){
  if(col == 8){
    count++;
    return;
  } else {
    for(int row = 0; row &lt; 8; ++row){
      if(board[row][col] == '.' &amp;&amp;
         left_diag[row-col+7] == false &amp;&amp;
         right_diag[row+col] == false &amp;&amp;
         rows[row] == false) {

        left_diag[row-col+7] = true;
        right_diag[row+col] = true;
        rows[row] = true;

        calculate_possibilities(col+1);

        left_diag[row-col+7] = false;
        right_diag[row+col] = false;
        rows[row] = false;
      }
    }
  }
}

int main(void){
  fio;
  for(int i = 0; i &lt; 8; i++){
    for(int j = 0; j &lt; 8; j++){
      std::cin&gt;&gt;board[i][j];
    }
  }
  calculate_possibilities(0);
  std::cout&lt;&lt;count;
  return 0;
}

</code></pre></div></div>


        
          <button title="Toggle Theme" class="theme-toggle">
  <svg viewBox="0 0 32 32" width="24" height="24" fill="currentcolor">
    <circle cx="16" cy="16" r="14" fill="none" stroke="currentcolor" stroke-width="4"></circle>
    <path d="
             M 16 0
             A 16 16 0 0 0 16 32
             z">
    </path>
  </svg>
</button>

        
        <div class="credits">&copy;&nbsp;2023&nbsp;Pradyumna Malladi
          &nbsp;
          •
          &nbsp;Powered by <a href="https://www.soopr.co" target="_blank" rel="noreferrer">Soopr</a>
          &nbsp;
          •
          &nbsp;Theme&nbsp; <a href="https://github.com/abhinavs/moonwalk" target="_blank" rel="noreferrer">Moonwalk</a>
        </div>
      </div>
    </main><script async defer src="https://sdk.soopr.co/soopr.js"></script></body>
</html>
