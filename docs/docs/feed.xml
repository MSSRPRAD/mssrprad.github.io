<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-10-21T20:06:26+05:30</updated><id>http://localhost:4000/feed.xml</id><title type="html">Pradyumna Malladi</title><subtitle>This is the personal website of Pradyumna Malladi. You can browse ./blog to read some of my posts and ./about to know more about me!
</subtitle><author><name>Pradyumna Malladi</name></author><entry><title type="html">Demo Post</title><link href="http://localhost:4000/demo-post" rel="alternate" type="text/html" title="Demo Post" /><published>2023-10-21T00:00:00+05:30</published><updated>2023-10-21T00:00:00+05:30</updated><id>http://localhost:4000/Demo-Post</id><content type="html" xml:base="http://localhost:4000/demo-post">&lt;h1 id=&quot;this-is-the-demo-post&quot;&gt;This is the Demo Post&lt;/h1&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;this-is-a-subheading&quot;&gt;This is a subheading&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Item 1&lt;/li&gt;
  &lt;li&gt;Item 2&lt;/li&gt;
  &lt;li&gt;Item 3&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ordered-lists&quot;&gt;Ordered Lists&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Item 1&lt;/li&gt;
  &lt;li&gt;Item 2&lt;/li&gt;
  &lt;li&gt;Item 3&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;image&quot;&gt;Image&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://octodex.github.com/images/bannekat.png&quot; alt=&quot;Benjamin Bannekat&quot; /&gt;&lt;/p&gt;</content><author><name>Malladi Pradyumna</name></author><category term="update" /><category term="miscellaneous" /><summary type="html">This is the Demo Post</summary></entry><entry><title type="html">August Updates</title><link href="http://localhost:4000/august-updates" rel="alternate" type="text/html" title="August Updates" /><published>2023-08-03T00:00:00+05:30</published><updated>2023-08-03T00:00:00+05:30</updated><id>http://localhost:4000/August-Updates</id><content type="html" xml:base="http://localhost:4000/august-updates">&lt;h1 id=&quot;hello-there&quot;&gt;Hello There!&lt;/h1&gt;

&lt;p&gt;I wish I could have said I got a lot of work done over the last two months or that I learnt a lot of new skills. Sadly that was not the case (surprise surprise).&lt;/p&gt;

&lt;h3 id=&quot;logs&quot;&gt;Logs:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Started solving the CSES problemset. Finished the Introductory Problems and am halfway through the Dynamic Programming ones. [Just coping right now saying ‘something is better than nothing’].&lt;/li&gt;
  &lt;li&gt;Got some work done on the &lt;strong&gt;Twitter-Clone&lt;/strong&gt; application. It has a not-so-bad backend and, I admit, a bad frontend. Have implemented the Register, Login, Post, Comment, Follow functionalities in the frontend. Some more work needs to be done on this but it feels boring now. I did not use anything fancy like Websockets or SSE’s because 1. They are tough to implement in Rust 2. It’s not a production grade application anyway.&lt;/li&gt;
  &lt;li&gt;Started Reading the Ramayana, in Sanskrit using the &lt;a href=&quot;https://ambuda.org/&quot;&gt;Ambuda&lt;/a&gt; website which provides पदच्छेद and easy dictionary searching for the meanings. I am also reading the English translation from &lt;a href=&quot;https://www.valmiki.iitk.ac.in/&quot;&gt;IITK-Ramayana&lt;/a&gt; simultaneously. I am in the 29Th सर्ग right now. I will make a separate post with my thoughts on this some other time.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Grind through CSES and regularly attempt Codeforces.&lt;/li&gt;
  &lt;li&gt;Looking forward to reading the विश्वामित्र story in the Ramayana and also the कुमारसम्भवम् story which is nearer.&lt;/li&gt;
  &lt;li&gt;Finish my Crossword program.&lt;/li&gt;
  &lt;li&gt;Going through https://rentry.org/llm-training  and learning how LLM’s work.&lt;/li&gt;
  &lt;li&gt;Get CUDA setup on my PC by some chad when I return to the Campus.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Malladi Pradyumna</name></author><category term="update" /><category term="miscellaneous" /><summary type="html">Hello There!</summary></entry><entry><title type="html">Cses Introductory Problems</title><link href="http://localhost:4000/cses-introductory-problems" rel="alternate" type="text/html" title="Cses Introductory Problems" /><published>2023-06-13T00:00:00+05:30</published><updated>2023-06-13T00:00:00+05:30</updated><id>http://localhost:4000/CSES-Introductory-Problems</id><content type="html" xml:base="http://localhost:4000/cses-introductory-problems">&lt;h1 id=&quot;1-weird-algorithm&quot;&gt;1. Weird Algorithm&lt;/h1&gt;

&lt;p&gt;Let’s try the most obvious solution:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void steps(int n) {
    while (n != 1) {
        std::cout&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&quot; &quot;;
        if (n % 2 == 0) {
            n /= 2;
        } else {
            n = 3 * n + 1;
        }
    }
    std::cout&amp;lt;&amp;lt;n;
    return;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;result&quot;&gt;Result:&lt;/h3&gt;

&lt;p&gt;TIME LIMIT EXCEEDED on some test cases.&lt;/p&gt;

&lt;p&gt;WRONG ANSWER on some test cases.&lt;/p&gt;

&lt;p&gt;Wrong answer probably means some overflow occurred. Let’s try changing all the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;long&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void steps(long n) {
    while (n != 1) {
        std::cout&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&quot; &quot;;
        if (n % 2 == 0) {
            n /= 2;
        } else {
            n = 3 * n + 1;
        }
    }
    std::cout&amp;lt;&amp;lt;n;
    return;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;result-1&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;ACCEPTED on all test cases!&lt;/p&gt;

&lt;h1 id=&quot;2-missing-number&quot;&gt;2. Missing Number&lt;/h1&gt;

&lt;p&gt;This is actually a very simple problem. We can find the sum of first n numbers by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n*(n+1)/2&lt;/code&gt; and just subtract the sum of the numbers we received.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;numeric&amp;gt;

int main(void){
    long n, sum=0;
    std::cin&amp;gt;&amp;gt;n;
    for(long i=0;i&amp;lt;n-1;i++){
        long no;
        std::cin&amp;gt;&amp;gt;no;
        sum+=no;
    }
    long actual_sum = n*(n+1)/2;
    long missing = actual_sum - sum;
    std::cout&amp;lt;&amp;lt;missing;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;result-2&quot;&gt;Result:&lt;/h3&gt;

&lt;p&gt;ACCEPTED!&lt;/p&gt;

&lt;h1 id=&quot;3-repetitions&quot;&gt;3. Repetitions&lt;/h1&gt;

&lt;p&gt;From what I understood we have to find the length of the longest repeating character sequence without gaps.&lt;/p&gt;

&lt;p&gt;Let’s try the O(N) approach.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

int main(void){
    std::string s;
    std::cin &amp;gt;&amp;gt; s;
    long len = s.length();
    long ans = 1;
    long max = 1;
    for(long i=0;i&amp;lt;len;i++){
        if(i&amp;lt;len-1){
            if(s[i]==s[i+1]){
                max++;
            } else {
                ans = std::max(max, ans);
                max = 1;
            }
        } else {
            ans = std::max(max, ans);
        }
    }
    std::cout&amp;lt;&amp;lt;ans;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Result: ACCEPTED!&lt;/p&gt;

&lt;p&gt;Nice!&lt;/p&gt;

&lt;h1 id=&quot;4-increasing-array&quot;&gt;4. Increasing Array&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;You are given an array of n
 integers. You want to modify the array so that it is increasing, i.e., every element is at least as large as the previous element.
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So a solution is obvious:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Go through all the elements&lt;/li&gt;
  &lt;li&gt;If an element is less than the previous element (if any) we need to increase it.&lt;br /&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;No of moves required = previous element - current element&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Update the current element to the previous value.&lt;/li&gt;
  &lt;li&gt;Add up all the moves required.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

int main(void){
    long n;
    long moves = 0;
    long prev = -1;
    std::cin&amp;gt;&amp;gt;n;
    for (long i = 0; i &amp;lt; n; i++)
    {
        long val;
        std::cin &amp;gt;&amp;gt; val;
        if (i &amp;gt; 0) {
            if (val &amp;lt; prev) {
                moves += prev - val;
                val = prev;
            }
        }
        prev = val;
    }
    std::cout&amp;lt;&amp;lt;moves;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;result-3&quot;&gt;Result:&lt;/h3&gt;

&lt;p&gt;ACCEPTED&lt;/p&gt;

&lt;h1 id=&quot;5-permutations&quot;&gt;5. Permutations&lt;/h1&gt;

&lt;p&gt;I need to thank Rupanuga Mishra for the logic for this one. I simply couldn’t figure it out :”(&lt;/p&gt;

&lt;p&gt;Logic is simple:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Loop from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i=0 to i=n/2 (i++)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Print the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ith&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n/2+ith&lt;/code&gt; numbers one after another&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Quick Implementation:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(long i=1;i&amp;lt;=n/2;i++){
    std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;i+n/2&amp;lt;&amp;lt;&quot; &quot;;
}
// If odd print the last one also
if(n%2==1){std::cout&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&quot; &quot;;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;result-4&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;FAILED on many test cases.&lt;/p&gt;

&lt;p&gt;Seeing the test cases it failed, I noticed a similarity. They are all either:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n==odd&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&amp;lt;6&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n==odd&lt;/code&gt; the last two numbers were &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n-1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; so moving the if statement at the end 
to the beginning should fix it. (Thanks Dhruv!)&lt;/p&gt;

&lt;p&gt;For the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&amp;lt;6&lt;/code&gt; I just added edge conditions (cheating according to Dhruv but it works haha)!&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;

int main(void){
    long n;
    std::cin&amp;gt;&amp;gt;n;
    if(n==4){
        std::cout&amp;lt;&amp;lt;&quot;3 1 4 2&quot;;
        return 0;
    }
    if(n==5){
        std::cout&amp;lt;&amp;lt;&quot;2 4 1 3 5&quot;;
        return 0;
    }
    if(n==1){
        std::cout&amp;lt;&amp;lt;&quot;1&quot;;
        return 0;
    }
    if(n&amp;lt;6){std::cout&amp;lt;&amp;lt;&quot;NO SOLUTION&quot;; return 0;}
    // If odd print the last one also
    if(n%2==1){std::cout&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&quot; &quot;;}
    for(long i=1;i&amp;lt;=n/2;i++){
        std::cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;i+n/2&amp;lt;&amp;lt;&quot; &quot;;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;result-5&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;ACCEPTED!&lt;/p&gt;

&lt;h1 id=&quot;6-number-spiral&quot;&gt;6. Number Spiral&lt;/h1&gt;

&lt;p&gt;Sadly I could not think of any elegant solution to the problem. After looking at it it seemed that the
solution could be found using some elaborate &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if-else&lt;/code&gt; blocks and so I did that.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Usage: find_no(y-1, x-1)
long find_no(long row, long col){
    long num;
    // Lower Left
    if (row&amp;gt;col){
        long starting_element_of_row = row%2==1? (row+1)*(row+1) : row*row+1; 
        num = row%2==0? starting_element_of_row + col : starting_element_of_row - col;
    } 
    // Upper Right
    else if (row&amp;lt;col) {
        long starting_element_of_column = col%2==0? (col+1)*(col+1) : col*col+1; 
        num = col%2==0? starting_element_of_column - row : starting_element_of_column + row; 
    } else 
    // Diagonal
    {
        num = row*row+row+1;
    }
    return num;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;result-6&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;ACCEPTED!&lt;/p&gt;

&lt;h1 id=&quot;7-two-knights&quot;&gt;7. Two Knights&lt;/h1&gt;

&lt;p&gt;This is a O(1) solution because there is a direct formula for the no of positions given a chessboard of some dimension.&lt;/p&gt;

&lt;p&gt;Let’s say there is a KxK chessboard. We can place two knights in it in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K^2C2&lt;/code&gt; possible ways. How many of these ways make the two knights attack each other?&lt;/p&gt;

&lt;p&gt;If two knights are attacking each other, they are at the corner squares of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3x2&lt;/code&gt; rectangle. In a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3x2&lt;/code&gt; rectangle there are 4 ways we can arrange two knights so as to attack each other. So now how many 3x2 rectangles can we construct in a KxK chessboard?&lt;/p&gt;

&lt;p&gt;Translating along the y-axis, we can have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K-3+1 = K-2&lt;/code&gt; positions for the rectangle.
Translating along the x-axis, we can have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K-2+1 = K-1&lt;/code&gt; positions for the rectangle.&lt;/p&gt;

&lt;p&gt;Total no of positions where the two knights are attacking each other: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4*(K-2)*(K-1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Total no of positions where the two knights are NOT attacking each other: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K^2C2-4*(K-2)*(K-1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Quick Implementation:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;long no_of_ways(long n){
    return (n*n*(n*n-1))/2 - 4*(n-1)*(n-2); 
}

int main(void){
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    long n;
    std::cin&amp;gt;&amp;gt;n;
    for(long i=1;i&amp;lt;=n;i++){
        std::cout&amp;lt;&amp;lt;no_of_ways(i)&amp;lt;&amp;lt;std::endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;result-7&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;ACCEPTED!&lt;/p&gt;

&lt;p&gt;Luckily there were no edge cases for this problem!&lt;/p&gt;

&lt;h1 id=&quot;8-two-sets&quot;&gt;8. Two Sets&lt;/h1&gt;

&lt;p&gt;So, I looked online and found out it is a DP Problem (which I unfortunately never learnt properly during my DSA Course.) Going briefly through some online brief explanations I saw the overall logic.&lt;/p&gt;

&lt;p&gt;Let us say we have a set like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{1,2,3,4,5,6,7}&lt;/code&gt;
The sum of the elements is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;28&lt;/code&gt; so we need to make two sets summing up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;14&lt;/code&gt; each.&lt;/p&gt;

&lt;h1 id=&quot;todo&quot;&gt;todo!()&lt;/h1&gt;

&lt;h1 id=&quot;9-bit-strings&quot;&gt;9. Bit Strings&lt;/h1&gt;

&lt;p&gt;This is a very simple problem. We just need to find 2^input. This can be done directly using a bitwise operation&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;

int main(void){
    const long MOD = 1000000007; // 10^9 + 7
    long input;
    std::cin&amp;gt;&amp;gt;input;
    long result = 1 &amp;lt;&amp;lt; input;
    std::cout&amp;lt;&amp;lt;result%MOD;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;result-8&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;FAILED on some test cases.&lt;/p&gt;

&lt;p&gt;Observing a failed test case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;input=447&lt;/code&gt; we are getting negative values for both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2^result&lt;/code&gt; and the final answer. We need to find a better way to do the power and % operations.&lt;/p&gt;

&lt;p&gt;Luckily on googling I found this: https://www.geeksforgeeks.org/exponential-squaring-fast-modulo-multiplication/&lt;/p&gt;

&lt;p&gt;Now let us use this method in our code. Basically we find &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2^input % MOD&lt;/code&gt; in a series of steps i=1 to i=n each time multiplying our input by 2 and taking the MOD.&lt;/p&gt;

&lt;p&gt;The property used is: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a*a % mod = (a%mod) * (a%mod)&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;

int main(void){
    const long long MOD = 1000000007; // 10^9 + 7
    long long input;
    std::cin&amp;gt;&amp;gt;input;
    long long res = 1;
    for(long long i=0;i&amp;lt;input;i++){
        res = (res*2);
        res = res%MOD;
    }
    std::cout&amp;lt;&amp;lt;res;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;result-9&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;ACCEPTED!
Cool let’s move on to the next one!&lt;/p&gt;

&lt;h1 id=&quot;10-trailing-zeros&quot;&gt;10. Trailing Zeros&lt;/h1&gt;

&lt;p&gt;Luckily this is a JEE Problem. We need to find the no of multiples of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt; in all the numbers upto the input number as that will give us the no of zeros.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt; can come as either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt; or any of it’s powers. No of occurences of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5^k&lt;/code&gt; in the numbers upto &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;input&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;box[input/5^k]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Quick Soln using this:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;

int main(void){
    long long n;
    std::cin&amp;gt;&amp;gt;n;
    long long zeros = 0;
    for(long long i=5;i&amp;lt;=n;i*=5){
        zeros += n/i;
        if(zeros==0) {
            break;
        }
    }
    std::cout&amp;lt;&amp;lt;zeros;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;result-10&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;ACCEPTED!&lt;/p&gt;

&lt;h1 id=&quot;11-coin-piles&quot;&gt;11. Coin Piles&lt;/h1&gt;

&lt;p&gt;So some maths now:
Let &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = coins in left pile&lt;/code&gt;
Let &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = coins in right pile&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We have two options for each of our operations:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Remove 2 coins from a and 1 coin from b&lt;/li&gt;
  &lt;li&gt;Remove 1 coin from a and 2 coins from b&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x = no of times 1 was performed&lt;/code&gt;.
Let &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y = no of times 2 was performed&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;total no of moves = x+y&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If at the end of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x+y&lt;/code&gt; operations, the two piles became empty, we have two conditions:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a = x*2 + y&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b = x + 2*y&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Adding:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a + b = 3*(x + y)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, we have 1 condition: That the sum of the two piles must be a multiple of 3!&lt;/p&gt;

&lt;p&gt;But, this condition is not sufficient. We have one more also!&lt;/p&gt;

&lt;p&gt;Let one pile be incredibly large and the other be incredibly small (less than twice the size of the other)! We keep on removing 2 elements from the bigger and one from the smaller but the smaller pile becomes empty first!!&lt;/p&gt;

&lt;p&gt;So, we need to ensure that the bigger pile is no bigger than twice the smaller!&lt;/p&gt;

&lt;p&gt;Quick Implementation:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

int main(void){
    long long t;
    std::cin &amp;gt;&amp;gt; t;
    for (long long i = 0; i&amp;lt;t; i++){
        long long a, b;
        std::cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
        if ((a+b)%3 == 0 &amp;amp;&amp;amp; 2*a &amp;gt;= b &amp;amp;&amp;amp; 2*b &amp;gt;= a)
            std::cout &amp;lt;&amp;lt; &quot;YES&quot; &amp;lt;&amp;lt; std::endl;
        else
            std::cout &amp;lt;&amp;lt; &quot;NO&quot; &amp;lt;&amp;lt; std::endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;result-11&quot;&gt;RESULT:&lt;/h3&gt;
&lt;p&gt;ACCEPTED!&lt;/p&gt;

&lt;h1 id=&quot;12-palindrome-string&quot;&gt;12. Palindrome String&lt;/h1&gt;

&lt;p&gt;First, we make a frequency array for the string. We see that if the total number of characters having odd frequency is odd, no such palindrome is possible.&lt;/p&gt;

&lt;p&gt;Let’s say we have the frequency array and making a palindrome is possible. How to make it?&lt;/p&gt;

&lt;p&gt;Let us make 2 strings for the left and right halves of the palindrome. Now let’s go through our freq array from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;26&lt;/code&gt;. If a character has even frequency, we can keep half of the count in the starting of palindrome and half at the end. If it has odd frequency just keep all of them in the middle!&lt;/p&gt;

&lt;p&gt;Not so quick implementation xD&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;

int main(void){
    std::string input;
    std::cin&amp;gt;&amp;gt;input;
    int freq[26] = {0};
    for(int i=0; i&amp;lt;input.length(); i++){
        freq[input[i]-&apos;A&apos;]++;
    }
    bool isOdd = input.length()%2 == 1;
    int noOfOdd = 0;
    for(int i=0; i&amp;lt;26; i++){
        if(freq[i]%2 == 1){
            noOfOdd++;
        }
    }
    if (noOfOdd &amp;gt; 1){
        std::cout&amp;lt;&amp;lt;&quot;NO SOLUTION&quot;;
    } else {
        std::string outputleft = &quot;&quot;;
        std::string outputright = &quot;&quot;;
        // Fill all the even freq characters first
        for(int i=0; i&amp;lt;26; i++){
            if(freq[i]%2 == 0){
                int num = freq[i]/2;
                while(num--){
                    outputleft += (char)(&apos;A&apos;+i);
                    outputright += (char)(&apos;A&apos;+i);
                }
            }
        }
        // Print the outputleft + odd freq character + outputright
        for(int i=0;i&amp;lt;outputleft.length();i++) std::cout&amp;lt;&amp;lt;outputleft[i];
        for(int i=0;i&amp;lt;26;i++){
            if(freq[i]%2 == 1){
                int num = freq[i];
                while(num--) std::cout&amp;lt;&amp;lt;(char)(&apos;A&apos;+i);
            }
        }
        for(int i=outputright.length()-1;i&amp;gt;=0;i--) std::cout&amp;lt;&amp;lt;outputright[i];
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;result-12&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;ACCEPTED on all test cases!&lt;/p&gt;

&lt;h1 id=&quot;13-gray-code&quot;&gt;13. Gray Code&lt;/h1&gt;

&lt;p&gt;This can be solved by recursion. Assume we already have the Gray Code for some &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;. How to get for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n+1&lt;/code&gt; ?&lt;/p&gt;

&lt;p&gt;Let’s consider the case of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n=2&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GRAY CODE (n = 2):
00
01
11
10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Now, for n=3 we observe that if we keep a zero in the starting of these numbers, each still differs by one from the next! Same if we keep a one! Also note that taking both of these together (second one in reverse), we get all the numbers in the gray code for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n=3&lt;/code&gt;!&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GRAY CODE (n = 3):
000
001
011
010
110
111
101
100
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Implementation:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;std::vector&amp;lt;std::string&amp;gt; gray_code(long long n){
    if(n==1){
        std::vector&amp;lt;std::string&amp;gt; vec;
        vec.push_back(&quot;0&quot;);
        vec.push_back(&quot;1&quot;);
        return vec;
    } else {
        std::vector&amp;lt;std::string&amp;gt; vec;
        std::vector&amp;lt;std::string&amp;gt; vecprev = gray_code(n-1);
        for(int i=0;i&amp;lt;vecprev.size();i++){
            vec.push_back(&quot;0&quot;+vecprev[i]);
        }
        for(int i=vecprev.size()-1;i&amp;gt;=0;i--){
            vec.push_back(&quot;1&quot;+vecprev[i]);
        }
        return vec;
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;result-13&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;ACCEPTED on all test cases!&lt;/p&gt;

&lt;h1 id=&quot;14-tower-of-hanoi&quot;&gt;14. Tower of Hanoi&lt;/h1&gt;

&lt;p&gt;I am really sorry I wrote a really big post for this one but my laptop lost power and everything was gone. Seems the work wasn’t saved (Loving first day of emacs already).&lt;/p&gt;

&lt;p&gt;So, A quick summary will have to suffice (No energy for anything more :”(  ) :&lt;/p&gt;

&lt;p&gt;The soln is simple. To move N Disks from Tower 1 to Tower 3 using Tower 2, We first move the top N-1 Disks to tower 2 and the Nth (Bottom Most) Disk to Tower 3. Then We Move the N-2 Disks on Tower 2 to Tower 3. It is a simple Recursion problem.&lt;/p&gt;

&lt;p&gt;Quick Implementation:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;utility&amp;gt;

typedef long long ll;
typedef std::pair&amp;lt;int, int&amp;gt; Move;

void tower_of_hanoi(ll from_tower, ll using_tower, ll to_tower, ll no_of_disks, std::vector&amp;lt;Move&amp;gt; &amp;amp;moves){
    if(no_of_disks == 0){
        // Base Case
        return;
    } else {
        // First move the N-1 disks to the middle tower
        tower_of_hanoi(from_tower, to_tower, using_tower, no_of_disks-1, moves);
        // Move one disk from the left tower to the right tower
        // Add the move to the moves vector
        moves.push_back(std::make_pair(from_tower, to_tower));
        // Move N-1 disks from the middle tower to the right tower
        tower_of_hanoi(using_tower, from_tower, to_tower, no_of_disks-1, moves);
    }
}


int main(void){
    ll n;
    std::cin&amp;gt;&amp;gt;n;
    std::vector&amp;lt;Move&amp;gt; moves;
    tower_of_hanoi(1, 2, 3, n, moves);
    std::cout&amp;lt;&amp;lt;moves.size()&amp;lt;&amp;lt;&quot;\n&quot;;
    for(const auto &amp;amp;move: moves) {
        std::cout&amp;lt;&amp;lt;move.first&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;move.second&amp;lt;&amp;lt;&quot;\n&quot;;
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;result-14&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;ACCEPTED! (on all test cases)&lt;/p&gt;

&lt;h1 id=&quot;15-creating-strings&quot;&gt;15. Creating Strings&lt;/h1&gt;

&lt;p&gt;We have to take a string, find all the permutations of it and return the output in alphabetical order.&lt;/p&gt;

&lt;p&gt;The method for generating permutations is pretty standard. If we store them in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;std::set&lt;/code&gt;, that will take care of the lexicographic ordering automatically for us.&lt;/p&gt;

&lt;p&gt;Implementation:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void permute(std::string str, int left, int right, std::set&amp;lt;std::string&amp;gt; &amp;amp;outputs){
  if(left == right) {
    std::cout&amp;lt;&amp;lt;str&amp;lt;&amp;lt;std::endl;
    outputs.insert(str);
  } else {
    for(int i=left;i&amp;lt;=right;i++){
      std::swap(str[left], str[i]);
      permute(str, left+1, right, outputs);
      std::swap(str[left], str[i]);
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;result-15&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;ACCEPTED!&lt;/p&gt;

&lt;h1 id=&quot;16-apple-division&quot;&gt;16. Apple Division&lt;/h1&gt;

&lt;p&gt;We have a set of some numbers. We have to divide it into two sets such that the difference in the sum of the two sets is the least and we have to find that sum.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ex Input:
5
3 2 7 4 1
Two Sets:
{2,3,4}, {7,1}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First let us sort the input:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7,4,3,2,1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then let us take a number from the left and insert into set 1 and take the next numbers till the sum exceeds the first number and insert into set two. If it exceeds, we repeat the process. In this way we can solve the problem!&lt;/p&gt;

&lt;p&gt;Eg Soln:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{7} {4,3,2}&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{7,1} {4,3,2}&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Implementation:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;set&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#define ll long long
#define fio std::ios_base::sync_with_stdio(false); std::cin.tie(NULL); std::cout.tie(NULL)

ll abs(ll a){
  if(a&amp;gt;0){
    return a;
  } else {
    return -1*a;
  }
}

ll partition(std::vector&amp;lt;ll&amp;gt; &amp;amp;inputs, std::vector&amp;lt;ll&amp;gt; &amp;amp;grp1, std::vector&amp;lt;ll&amp;gt; &amp;amp;grp2, ll n){
  std::sort(inputs.begin(), inputs.end(), std::greater&amp;lt;ll&amp;gt;());
  bool insert_in_grp1 = true;
  ll sum1 = 0, sum2 = 0;
  for(auto x: inputs){
    if(sum1&amp;gt;=sum2 &amp;amp;&amp;amp; sum1+sum2 != 0){
      insert_in_grp1 = false;
    } else {
      insert_in_grp1 = true;
    };
    if(insert_in_grp1){
      grp1.push_back(x);
      sum1 += x;
    } else {
      grp2.push_back(x);
      sum2 += x;
    }
  }
  return abs(sum1-sum2);
}

int main(void){
  fio;
  ll n;
  ll diff = 0;
  std::cin&amp;gt;&amp;gt;n;
  std::vector&amp;lt;ll&amp;gt; inputs(n);
  std::vector&amp;lt;ll&amp;gt; grp1, grp2;
  for(ll i = 0; i &amp;lt; n; i ++){
    std::cin&amp;gt;&amp;gt;inputs[i];
  }
  diff = partition(inputs, grp1, grp2, n);
  std::cout&amp;lt;&amp;lt;diff;
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;result-16&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;FAILED! (On many test cases!)&lt;/p&gt;

&lt;p&gt;Maybe we are better off finding all the different possible splits and choosing the minimum difference instead….&lt;/p&gt;

&lt;p&gt;Also the constraint is: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 &amp;lt;= n &amp;lt;= 20&lt;/code&gt; which seems very favourible for a slow algorithm.&lt;/p&gt;

&lt;p&gt;There is a very simple way to get all divisions of a set into two subsets. We go through all the numbers from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2^n -1&lt;/code&gt; and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1/0&lt;/code&gt; in the binary representation of each of indicate whether the element at that particular index is present in grp1 or grp2. Let us try to generate all the divisions using this and then go through them and choose the one where the sum is the least!&lt;/p&gt;

&lt;p&gt;(Not so quick) implementations!&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;limits&amp;gt;

#define ll long long
#define fio std::ios_base::sync_with_stdio(false); std::cin.tie(NULL); std::cout.tie(NULL)

ll partition(const std::vector&amp;lt;ll&amp;gt;&amp;amp; input, std::vector&amp;lt;ll&amp;gt;&amp;amp; grp1, std::vector&amp;lt;ll&amp;gt;&amp;amp; grp2, ll n) {
    std::vector&amp;lt;ll&amp;gt; tmp_grp1, tmp_grp2;
    ll diff = std::numeric_limits&amp;lt;ll&amp;gt;::max();
    for (ll i = 0; i &amp;lt; (1 &amp;lt;&amp;lt; n) - 1; i++) {
        ll sum1 = 0, sum2 = 0;
        tmp_grp1.clear();
        tmp_grp2.clear();
        for (ll index = 0; index &amp;lt; input.size(); index++) {
            if ((i &amp;amp; (1 &amp;lt;&amp;lt; index)) == 0) {
                tmp_grp1.push_back(input[index]);
                sum1 += input[index];
            } else {
                tmp_grp2.push_back(input[index]);
                sum2 += input[index];
            }
        }
        if (std::abs(sum1 - sum2) &amp;lt; diff) {
            diff = std::abs(sum1 - sum2);
            grp1 = tmp_grp1;
            grp2 = tmp_grp2;
        }
    }
    return diff;
}

int main() {
    fio;
    ll n;
    std::cin&amp;gt;&amp;gt;n;
    std::vector&amp;lt;ll&amp;gt; input(n);
    for(ll i = 0; i &amp;lt; n; ++i){
      std::cin&amp;gt;&amp;gt;input[i];
    }
    std::vector&amp;lt;ll&amp;gt; grp1, grp2;
    ll diff = partition(input, grp1, grp2, n);
    std::cout &amp;lt;&amp;lt; diff &amp;lt;&amp;lt; std::endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;result-17&quot;&gt;Result:&lt;/h3&gt;
&lt;p&gt;ACCEPTED! (On all test cases!)&lt;/p&gt;

&lt;h1 id=&quot;17-chessboard-and-queens&quot;&gt;17. Chessboard and Queens&lt;/h1&gt;

&lt;p&gt;From now onwards I will not add any explanations as I don’t have much time.&lt;/p&gt;

&lt;p&gt;Maybe later I will add the explanations….&lt;/p&gt;

&lt;p&gt;Solution:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include&amp;lt;iostream&amp;gt;
#define fio std::ios_base::sync_with_stdio(false); std::cin.tie(NULL); std::cout.tie(NULL)

int count = 0;
char board[8][8];
// Availibility of a particular left/right diagonal and row
bool left_diag[15] = {false}, right_diag[15] = {false}, rows[7] = {false};


void calculate_possibilities(int col){
  if(col == 8){
    count++;
    return;
  } else {
    for(int row = 0; row &amp;lt; 8; ++row){
      if(board[row][col] == &apos;.&apos; &amp;amp;&amp;amp;
         left_diag[row-col+7] == false &amp;amp;&amp;amp;
         right_diag[row+col] == false &amp;amp;&amp;amp;
         rows[row] == false) {

        left_diag[row-col+7] = true;
        right_diag[row+col] = true;
        rows[row] = true;

        calculate_possibilities(col+1);

        left_diag[row-col+7] = false;
        right_diag[row+col] = false;
        rows[row] = false;
      }
    }
  }
}

int main(void){
  fio;
  for(int i = 0; i &amp;lt; 8; i++){
    for(int j = 0; j &amp;lt; 8; j++){
      std::cin&amp;gt;&amp;gt;board[i][j];
    }
  }
  calculate_possibilities(0);
  std::cout&amp;lt;&amp;lt;count;
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Malladi Pradyumna</name></author><category term="welcome" /><category term="miscellaneous" /><summary type="html">1. Weird Algorithm</summary></entry><entry><title type="html">Welcome Post</title><link href="http://localhost:4000/welcome-post" rel="alternate" type="text/html" title="Welcome Post" /><published>2023-06-11T00:00:00+05:30</published><updated>2023-06-11T00:00:00+05:30</updated><id>http://localhost:4000/welcome-post</id><content type="html" xml:base="http://localhost:4000/welcome-post">&lt;h1 id=&quot;welcome&quot;&gt;Welcome!&lt;/h1&gt;

&lt;p&gt;This is my personal website which I will try to maintain regularly. I will be posting some blog articles over the next few months here and share some parts of my work and life.&lt;/p&gt;

&lt;p&gt;As for &lt;strong&gt;why&lt;/strong&gt; have a personal website, I have thought about it and :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It is good for your mental health to write frequently and you get to organize your thoughts more often.&lt;/li&gt;
  &lt;li&gt;It gives me an excuse to actually stop wasting time on mindless internet scrolling and actually do something productive instead.&lt;/li&gt;
  &lt;li&gt;It is too easy (and free!) to make and host one nowadays that there is no excuse to not have one.
&lt;em&gt;Edit: I’m sorry it is not that easy to make and host one. React is spawn of Satan. Leaving this here for posterity.&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;Even if it amounts to nothing at least I have gained some technical knowledge making the blog.
&lt;em&gt;Edit: Since I ended up using a jekyll template even this point is moot now I guess haha&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As for the kind of content I would like to post here:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Maintain a list of projects that I am doing/have done/currently am doing.&lt;/li&gt;
  &lt;li&gt;Some blog posts with my thoughts on various things.&lt;/li&gt;
  &lt;li&gt;Some technical posts on machine learning (Summarizing as I learn for better retention)&lt;/li&gt;
  &lt;li&gt;Anything else I feel like posting.&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Malladi Pradyumna</name></author><category term="welcome" /><category term="miscellaneous" /><summary type="html">Welcome!</summary></entry></feed>