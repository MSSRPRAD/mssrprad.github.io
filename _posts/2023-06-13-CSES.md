---
layout: post
author: Malladi Pradyumna
tags: [welcome, miscellaneous]
---

# Introductory Problems

# 1. Weird Algorithm

Let's try the most obvious solution:
```
void steps(int n) {
    while (n != 1) {
        std::cout<<n<<" ";
        if (n % 2 == 0) {
            n /= 2;
        } else {
            n = 3 * n + 1;
        }
    }
    std::cout<<n;
    return;
}
```
### Result: 

TIME LIMIT EXCEEDED on some test cases.

WRONG ANSWER on some test cases.

Wrong answer probably means some overflow occurred. Let's try changing all the `int` to `long` 
```
void steps(long n) {
    while (n != 1) {
        std::cout<<n<<" ";
        if (n % 2 == 0) {
            n /= 2;
        } else {
            n = 3 * n + 1;
        }
    }
    std::cout<<n;
    return;
}
```

### Result:
ACCEPTED on all test cases!

# 2. Missing Number

This is actually a very simple problem. We can find the sum of first n numbers by `n*(n+1)/2` and just subtract the sum of the numbers we received.

```
#include <iostream>
#include <vector>
#include <numeric>

int main(void){
    long n, sum=0;
    std::cin>>n;
    for(long i=0;i<n-1;i++){
        long no;
        std::cin>>no;
        sum+=no;
    }
    long actual_sum = n*(n+1)/2;
    long missing = actual_sum - sum;
    std::cout<<missing;
    return 0;
}
```

Result: ACCEPTED!

# 3. Repetitions

From what I understood we have to find the length of the longest repeating character sequence without gaps.

Let's try the O(N) approach.

```
#include <iostream>
#include <string>

int main(void){
    std::string s;
    std::cin >> s;
    long len = s.length();
    long ans = 1;
    long max = 1;
    for(long i=0;i<len;i++){
        if(i<len-1){
            if(s[i]==s[i+1]){
                max++;
            } else {
                ans = std::max(max, ans);
                max = 1;
            }
        } else {
            ans = std::max(max, ans);
        }
    }
    std::cout<<ans;
    return 0;
}
```
Result: ACCEPTED!

Nice!

# 4. Increasing Array

`You are given an array of n
 integers. You want to modify the array so that it is increasing, i.e., every element is at least as large as the previous element.
`

So a solution is obvious:
1. Go through all the elements
2. If an element is less than the previous element (if any) we need to increase it.<br>`No of moves required = previous element - current element`
3. Update the current element to the previous value.
4. Add up all the moves required.

```
#include <iostream>

int main(void){
    long n;
    long moves = 0;
    long prev = -1;
    std::cin>>n;
    for (long i = 0; i < n; i++)
    {
        long val;
        std::cin >> val;
        if (i > 0) {
            if (val < prev) {
                moves += prev - val;
                val = prev;
            }
        }
        prev = val;
    }
    std::cout<<moves;
    return 0;
}
```
Result: ACCEPTED
